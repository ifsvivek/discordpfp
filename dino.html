<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Run: SVG Dash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            overscroll-behavior-y: contain;
            touch-action: manipulation;
        }
        canvas {
            /* image-rendering helps keep pixels sharp if SVGs are simple/blocky */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background-color: #ffffff;
        }
        #loadingMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #333;
        }
        /* Ensure button clicks work reliably on touch devices */
        #restartButton {
             cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl text-center mb-4">
        <h1 class="text-2xl font-bold text-gray-700 mb-2">Pixel Run: SVG Dash</h1>
        <div id="info" class="text-lg font-semibold text-gray-600">
            Score: <span id="score" class="font-bold text-blue-600">0</span> | High Score: <span id="highScore" class="font-bold text-green-600">0</span>
        </div>
    </div>

    <div class="w-full max-w-3xl relative">
        <canvas id="gameCanvas" width="800" height="250" class="w-full border-2 border-gray-400 rounded shadow-md"></canvas>
        <div id="loadingMessage" class="font-semibold">Loading Assets...</div>
        <div id="gameOver" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-60 text-white p-6 rounded hidden">
            <h2 class="text-4xl font-bold mb-4 text-red-500">Game Over!</h2>
            <div id="finalScore" class="text-2xl mb-6"></div>
            <button id="restartButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded text-lg shadow transition duration-200 ease-in-out">
                Restart
            </button>
        </div>
    </div>

    <div id="controls" class="mt-4 text-sm text-gray-500">
        Press SPACE or TAP screen to Jump
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const loadingMessage = document.getElementById('loadingMessage');

        // --- Game Constants ---
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const GROUND_Y = CANVAS_HEIGHT - 40;
        const GRAVITY = 0.6;
        const JUMP_FORCE = -13;
        const INITIAL_SPEED = 4;
        const SPEED_INCREMENT = 0.0015;
        const MIN_OBSTACLE_SPAWN_INTERVAL = 55;
        const MAX_OBSTACLE_SPAWN_INTERVAL = 130;

        // --- Define drawing dimensions for SVGs ---
        const PLAYER_DRAW_WIDTH = 40;
        const PLAYER_DRAW_HEIGHT = 43;
        const CACTUS_DRAW_WIDTH = 23; // Width for the specific SVG below
        const CACTUS_DRAW_HEIGHT = 46; // Height for the specific SVG below

        // --- Assets (SVG Strings) ---
        // Simple SVG Dino - viewBox defines coordinate system, width/height are suggested render size
        const DINO_SVG_STRING = `<svg viewBox="0 0 40 43" xmlns="http://www.w3.org/2000/svg" fill="#333">
            <rect x="1" y="0" width="18" height="10" rx="2"/>
            <rect x="19" y="3" width="5" height="7" rx="1"/>
            <rect x="10" y="10" width="25" height="15" rx="2"/>
            <rect x="35" y="12" width="5" height="10" rx="2"/>
            <rect x="12" y="25" width="8" height="18" rx="2"/>
            <rect x="25" y="25" width="8" height="18" rx="2"/>
            </svg>`;

        // Simple SVG Cactus - Using paths for a slightly more organic look
        const CACTUS_SVG_STRING_1 = `<svg viewBox="0 0 23 46" xmlns="http://www.w3.org/2000/svg" fill="#287d3c"> <rect x="7" y="0" width="9" height="46" rx="3"/>
            <rect x="0" y="10" width="12" height="7" rx="3"/>
            <rect x="11" y="22" width="12" height="7" rx="3"/>
            </svg>`;

        // --- Create Data URIs ---
        // Use encodeURIComponent for robustness, though simple SVGs might work without it.
        const DINO_SRC = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(DINO_SVG_STRING);
        const CACTUS_SOURCES_SVG = [
            'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(CACTUS_SVG_STRING_1)
            // Add more cactus SVG strings and URIs here if desired
        ];

        // --- Asset Loading ---
        let assetsLoaded = 0;
        const totalAssets = 1 + CACTUS_SOURCES_SVG.length; // Dino + Cacti SVGs
        const dinoImage = new Image();
        const cactusImages = [];
        let gameReady = false; // Flag to indicate if assets are loaded

        function assetLoaded(assetName) {
            assetsLoaded++;
            console.log(`Asset loaded: ${assetName} (${assetsLoaded}/${totalAssets})`);
            if (assetsLoaded === totalAssets) {
                console.log("All assets loaded. Starting game...");
                gameReady = true;
                loadingMessage.style.display = 'none';
                // Dimensions are now fixed constants, no need to read from image here
                startGame();
            }
        }

        // --- Load Images from SVG Data URIs ---
        console.log("Initiating asset loading...");
        dinoImage.onload = () => assetLoaded('Dino');
        dinoImage.onerror = () => console.error("Error loading Dino SVG");
        dinoImage.src = DINO_SRC;

        CACTUS_SOURCES_SVG.forEach((src, index) => {
            const img = new Image();
            img.onload = () => assetLoaded(`Cactus ${index + 1}`);
            img.onerror = () => console.error(`Error loading Cactus ${index + 1} SVG`);
            img.src = src;
            cactusImages.push(img);
        });

        // --- Game State Variables ---
        let player;
        let obstacles = [];
        let gameSpeed;
        let score;
        let highScore = localStorage.getItem('pixelRunHighScoreSVG') || 0;
        let frames;
        let nextObstacleSpawnFrame;
        let isGameOver;
        let animationFrameId;

        // --- Player Object ---
        function createPlayer() {
             return {
                x: 60,
                y: GROUND_Y - PLAYER_DRAW_HEIGHT, // Use fixed height
                width: PLAYER_DRAW_WIDTH,         // Use fixed width
                height: PLAYER_DRAW_HEIGHT,       // Use fixed height
                velocityY: 0,
                isJumping: false,
                image: dinoImage,

                draw: function() {
                    // Check image.complete as a fallback, though onload should handle readiness
                    if (this.image.complete && this.image.naturalHeight !== 0) {
                         ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    } else if (gameReady) { // Only draw fallback if game has loaded but image somehow failed
                         console.warn("Dino image not ready, drawing fallback rect.");
                         ctx.fillStyle = '#333';
                         ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                },

                update: function() {
                    // Apply gravity
                    if (this.y < GROUND_Y - this.height || this.velocityY < 0) {
                        this.velocityY += GRAVITY;
                        this.y += this.velocityY;
                    }
                    // Prevent falling through ground
                    if (this.y > GROUND_Y - this.height) {
                        this.y = GROUND_Y - this.height;
                        this.velocityY = 0;
                        this.isJumping = false;
                    }
                },

                jump: function() {
                    // Allow jump slightly before landing
                    if (!this.isJumping && this.y >= GROUND_Y - this.height - 5) {
                        this.velocityY = JUMP_FORCE;
                        this.isJumping = true;
                    }
                }
            };
        }

        // --- Obstacle Object ---
        class Obstacle {
            constructor() {
                const cactusIndex = Math.floor(Math.random() * cactusImages.length);
                this.image = cactusImages[cactusIndex];
                // Use fixed dimensions defined above
                this.width = CACTUS_DRAW_WIDTH;
                this.height = CACTUS_DRAW_HEIGHT;
                this.x = CANVAS_WIDTH;
                this.y = GROUND_Y - this.height; // Position based on fixed height
            }

            draw() {
                 if (this.image.complete && this.image.naturalHeight !== 0) {
                     ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                 } else if (gameReady) {
                     console.warn("Cactus image not ready, drawing fallback rect.");
                     ctx.fillStyle = '#d9534f';
                     ctx.fillRect(this.x, this.y, this.width, this.height);
                 }
            }

            update() {
                this.x -= gameSpeed;
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            if (isGameOver || !gameReady) return; // Don't run if game over or not ready

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw Ground
            ctx.fillStyle = '#6b7280'; // Tailwind gray-500
            ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, 4);

            player.update();
            player.draw();

            manageObstacles();

            if (checkCollisions()) {
                triggerGameOver();
                return;
            }

            score++;
            gameSpeed += SPEED_INCREMENT;
            scoreElement.textContent = score;

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Obstacle Management ---
        function manageObstacles() {
            frames++;
            if (frames >= nextObstacleSpawnFrame) {
                obstacles.push(new Obstacle());
                frames = 0;
                const baseInterval = MIN_OBSTACLE_SPAWN_INTERVAL + Math.random() * (MAX_OBSTACLE_SPAWN_INTERVAL - MIN_OBSTACLE_SPAWN_INTERVAL);
                // Faster speed = shorter interval, with minimum threshold
                nextObstacleSpawnFrame = Math.max(30, baseInterval - (gameSpeed * 4));
            }

            // Update and draw existing obstacles, remove off-screen ones
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                obstacles[i].draw();
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }

        // --- Collision Detection ---
        function checkCollisions() {
            for (const obstacle of obstacles) {
                 // AABB collision check - adjust padding for better feel
                 const hitBoxPaddingX = 5; // Reduce horizontal hitbox slightly
                 const hitBoxPaddingY = 3; // Reduce vertical hitbox slightly
                if (
                    player.x < obstacle.x + obstacle.width - hitBoxPaddingX &&
                    player.x + player.width > obstacle.x + hitBoxPaddingX &&
                    player.y < obstacle.y + obstacle.height - hitBoxPaddingY &&
                    player.y + player.height > obstacle.y + hitBoxPaddingY
                ) {
                    return true; // Collision
                }
            }
            return false; // No collision
        }

        // --- Game Over Handling ---
        function triggerGameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            gameOverElement.classList.remove('hidden');
            finalScoreElement.textContent = `Your Score: ${score}`;
            if (score > highScore) {
                highScore = score;
                // Use a different key for SVG version high score
                localStorage.setItem('pixelRunHighScoreSVG', highScore);
                highScoreElement.textContent = highScore;
            }
        }

        // --- Game Initialization / Restart ---
        function startGame() {
            // Ensure this is only called after assets are ready
            if (!gameReady) {
                 console.warn("Attempted to start game before assets were ready.");
                 return;
            }
            console.log("Starting/Restarting game state...");
            player = createPlayer(); // Re-create player
            player.y = GROUND_Y - player.height; // Ensure correct initial Y
            player.velocityY = 0;
            player.isJumping = false;

            obstacles = [];
            gameSpeed = INITIAL_SPEED;
            score = 0;
            frames = 0;
            nextObstacleSpawnFrame = MAX_OBSTACLE_SPAWN_INTERVAL; // Initial spawn delay
            isGameOver = false;

            scoreElement.textContent = score;
            highScoreElement.textContent = highScore; // Ensure HS displayed correctly
            gameOverElement.classList.add('hidden'); // Hide game over screen

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Start the game loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Input Handling ---
        function handleInput(event) {
             // Ignore input if game isn't ready yet
             if (!gameReady) return;

            if (isGameOver) {
                // Allow restart via space/tap only if game over screen is visible
                if ((event.code === 'Space' || event.type === 'touchstart' || event.type === 'mousedown') && !gameOverElement.classList.contains('hidden')) {
                    // Prevent restart if click/tap was exactly on the button (let button handler do it)
                     if (event.target !== restartButton && !restartButton.contains(event.target)) {
                         event.preventDefault();
                         startGame();
                     }
                }
                return; // Don't jump if game is over
            }

            // Handle jump
            if (event.code === 'Space' || event.type === 'touchstart' || event.type === 'mousedown') {
                event.preventDefault();
                player.jump();
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleInput);
        // Add listeners to the document for wider capture area, especially for touch
        document.addEventListener('touchstart', handleInput, { passive: false }); // passive: false needed for preventDefault
        document.addEventListener('mousedown', handleInput);

        // Ensure button click works reliably and doesn't trigger document handler
        restartButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling up to document
            if (gameReady) { // Only allow restart if game assets are loaded
                startGame();
            }
        });

        // --- Initial Setup ---
        highScoreElement.textContent = highScore; // Display high score on load
        // The game itself will be started by the asset loader callback `assetLoaded()`
        console.log("Game setup complete. Waiting for assets...");

    </script>

</body>
</html>
